# 11단원 - CPU 스케줄링

## CPU 스케줄링 개요

- **멀티 프로그래밍**

→ 하나의 프로세서가 하나의 프로세스를 수행하는 동안(입출력 작업의 종료를 대기할 동안) 다른 프로세스에 접근할 수 있도록 하는 방법 

(최대한 많은 CPU를 활동하도록 하기 위함: 활용도↑)

여러개의 프로세스가 동시에 메모리에 로드, 프로세스가 CPU를 선점해서 실행

입출력이 완료될 때까지 기다리는 시간을 버리지 말고 다른 프로세스를 처리할 수 있도록 해주는 것

단점: 어느 한 프로그램이 CPU 사용 시간이 길어지면 다른 프로세스는 계속 대기를 해야 한다

<br>

- **멀티 프로세싱**

→ 여러 개의 프로세서(CPU 코어)를 사용하여 여러 개의 프로세스를 동시에 실행하는 방법

멀티 프로세싱은 프로세서들이 독립적으로 작업을 처리하므로, 병렬 처리가 가능하며 성능 향상을 가져올 수 있습니다.

<br>

- **멀티 태스킹**

→ 다수의 작업(Task)을 운영체제의 스케줄링에 의해 번갈아 가며 수행되도록 해주는 것

아주 짧은 시간만을 실행되도록 하여 각 프로그램의 작업을 아주 작은 단위로 번갈아 가며 처리, 작업 응답 시간을 최소화

멀티태스킹을 위해 운영체제는 CPU를 효율적으로 분배하기 위한 CPU 스케줄링 알고리즘을 사용

<br>
<br>

### CPU 스케줄링

→ 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 방법

준비 큐에 있는 프로세스들 중에서 어느 프로세스에게 CPU를 할당할 것인지

(큐에 들어간 순서대로 실행을 하는데 이를 우선순위에 따라 다시 정렬하는 방식)

최신 운영체제에서는 실질적으로 프로세스가 아니라 커널 수준 스레드를 스케줄 한다.

(os커널은 CPU스케줄링을 커널스레드를 가지고 스케줄링을 한다.)

멀티프로그램 운영체제의 기초 (필수)

CPU사용률을 최대화시키기 위함

⇒ 컴퓨터 성능과 직결된다.

<br>
<br>

### **프로세스의 연산**

대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행. (실행 상태와 대기 상태를 반복하면서 실행)

⇒ CPU를 사용하여 명령어 실행 → 입력받은 내용을 보조기억장치에 저장 → CPU사용하여 명령어 실행 → 입력한 내용을 화면에 출력 (과정 반복)

![프로세스의 연산](./img/프로세스%20실행과정.png)

<ins>입출력 집중 프로세스 (IO bound)</ins>: 입출력 작업이 많은 프로세스 (비디오 재생, 디스크 백업 작업 등 / 입출력 버스트가 많은 프로세스)

<ins>CPU 집중 프로세스 (CPU bound)</ins>: CPU작업이 많은 프로세스 (복잡한 수학 연산, 컴파일, 그래픽 처리 작업 담당 등 / CPU 버스트가 많은 프로세스)

프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.

<br>

+) <ins>CPU 버스트</ins>: CPU를 이용하는 작업. 주로 실행(running)상태

<ins>입출력 버스트</ins>: 입출력장치를 기다리는 작업. 주로 대기, 준비 (waiting, ready) 상태

⇒ 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행된다고 볼 수 있다.

평균적으로 CPU버스트보다 입출력 버스트의 빈도가 높아 CPU스케줄링으로 CPU효율이 올라갈 수 있다.

<br>
<br>

### **스케줄링 큐**

→ 운영체제가 메모리로 적재되고 싶은 (새로 생성되는), CPU를 이용하고싶은, 특정 입출력장치를 이용하고 싶은 프로세스들을 큐에 삽입하여 줄 세우는 것

(반드시 선입선출일 필요는 없다)

운영체제가 관리하는 대부분의 자원은 큐로 관리된다.

![스케줄링 큐](./img/스케줄링%20큐.png)

<br>

- **준비 큐**

→ CPU 할당을 기다리는 프로세스들을 위한 큐

큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 우선순위가 높은 프로세스를 먼저 실행한다.

<br>

- **대기 큐**

→ 입출력장치를 기다리는 프로세스들을 위한 큐

같은 장치를 요구한 프로세스들 끼리 대기 큐에서 대기

<br>

입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, PCB를 준비 상태로 변경하여 준비 큐로 이동시킨 뒤 대기 큐에서 제거

<br>
<br>

- <ins>CPU스케줄러</ins>

→ 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다.

선택 절차는 CPU스케줄러에 의해 수행된다.

실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.

<br>

- <ins>CPU스케줄링의 의사결정 (scheduling decision: 프로세스를 새로 선택해야하는 경우)</ins>
    1. 실행 -> 대기
    2. 실행 -> 준비
    3. 대기 -> 준비
    4. process terminates (종료)

1,4 - 비선점형
2,3 - 선점형 or 비선점형

<br>

- **선점형 스케줄링**

→ 프로세스가 이용 중인 자원을 <ins>빼앗을 수 있는</ins> 스케줄링 방식 (어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식 / ex: 일정한 시간 할당)

대부분의 운영체제가 차용하는 방식

<ins>장점</ins>: 한 프로세스의 자원 독점을 막고 프로세스들에게 고른 자원 배분 가능

<ins>단점</ins>: 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

<br>

- **비선점형 스케줄링**

→ 자원을 <ins>빼앗을 수 없는</ins> 스케줄링 방식 (<ins>자원 독점</ins>할 수 있는 스케줄링 방식)

<ins>장점</ins>: 문맥 교환 횟수가 적어 오버헤드가 날 가능성이 줄어든다.

<ins>단점</ins>: 당장 자원을 사용해야 할 급한 상황에도 기다리는 수밖에 없다.

모든 프로세스의 고른 자원 분배가 안된다.

<br>
<br>

- <ins>디스패쳐 (Dispatcher)</ins>

→ CPU코어의 컨트롤을 (CPU스케줄러가 선택한 프로세스에) 넘겨주는 것
문맥교환을 해주는 모듈
프로세스에 CPU를 넘겨주는 (할당해주는) 과정

- 기능
    - 한 프로세스에서 다른프로세스로의 문맥교환
    - 유저 모드의 전환
    - 유저 프로그램을 새로운 프로세스의 적당한 위치로 이동

⇒ 스케줄러가 선택, 디스페쳐가 스위칭(교체)

<br>

+) 유저 모드: 유저(사용자)가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 침범하지 못하는 모드

<br>

- Dispatch latency = context switching delay (디스페치 지연시간)

→ 현 프로세스의 PCB를 어딘가에 저장하고 멈춰뒀던 (저장해뒀던) PCB를 불러오는 과정
빠를수록 시스템의 효율성은 빠르다

<br>
<br>

- **우선순위**

→ CPU를 할당받을 수 있는 우선순위 (우선순위가 높을수록 빨리 처리해야하는 것)

운영체제는 프로세스별로 부여된 우선순위를 보고 CPU스케줄링을 수행

운영체제는 각 프로세스의  PCB에 우선순위를 명시, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정.

<br>

if) CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU자원을 요구 했을 때

⇒ 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동, 

그 다음 CPU 집중 프로세스에서 집중적으로 CPU를 할당하는 것이 더 효율적.

입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정. 때문에 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문

<br>

+) 우선순위가 높은 프로세스로는 실시간 프로세스, 일부 백그라운드 프로세스 등 다양.

유닉스, 리눅스, macOS 등의 유닉스 운영체제: ps -el 명렁어로 확인, nice로 우선순위 변경

윈도우: Process Explorer 소프트웨어로 확인

<br>
<br>
<br>

## CPU 스케줄링 알고리즘

→ 선입 선처리, 최단 작업 우선, 라운드 로빈, 최소 잔여 시간 우선, 우선순위, 다단계 큐, 다단계 피드백 큐 스케줄링 알고리즘 등

<br>

- <ins>스케줄링의 기준</ins>
    - CPU 사용률: CPU를 가능한 빠르고 많이 사용하게 한다
    - 처리량: 단위시간내에 프로세스의 완결하는 숫자를 높이자 (단위 시간당 완료된 프로세스의 개수)
    - 처리 (turnaround) 시간: 어떤 프로세스가 도착하고 난다음에 실행한뒤 종료됐을때까지의 시간을 최소화 (프로세스의 제출 시간과 완료 시간의 간격)
    - 대기 시간(Waiting Time): 대기시간(프로세스가 준비 큐에서 대기하면서 보낸 시간의 합) 최소화
    - 응답 시간: 응답하는 타임(하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간) 을 최소화시킴

<br>
<br>

### **선입 선처리 (= FCFS)**

→ 준비된 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식

CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식 ⇒ 프로세스들이 기다리는 시간이 매우 길어질 수 있다

<br>

+) <ins>호위 효과</ins>: 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것

(짧은 하나의 프로세스를 작동시키기위해 그 프로세스 앞의 모든 긴 프로세스만큼의 시간을 기다려야한다. → 평균 대기 시간이 길어질 수 있다)

<br>
<br>

### **최단 작업 우선 (= SJF)**

→ 큐에 삽입된 프로세스들 중 CPU이용 시간의 <ins>길이가 가장 짧은 프로세스</ins>부터 실행하는 스케줄링 방식

<ins>비선점형 스케줄링 알고리즘</ins>으로 분류

같은 이용 길이라면 먼저 들어온 프로세스부터 실행

평균 대기시간에서는 최적의 알고리즘

<br>

+) <ins>CPU사용시간을  구하는 방법</ins>

SJF를 사용하기 위해서는 각 프로세스들의 CPU사용 시간을 알아야한다.

정확히는 알 수 없고 <ins>근사적으로 예측하여 구한다</ins>

⇒ 과거에 측정된 CPU사용 기록 값을 가지고 지수적 평균을 낸다 (최근의 기록에 가중치를 좀 더 두어 계산)

![계산식 공식](./img/CPU사용시간%20구하는%20공식.png)

<br>
<br>

### **라운드 로빈 (RR, 시간단위로 시분할한 FCFS)**

→ 선입 선처리 스케줄링 + 타임 슬라이스 (: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미, 보통 10~100 milliseconds is length)

정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링

레디큐는 서클 큐로 구현

<br>

- <ins>프로세스가 time quantum보다 짧을 때</ins>
1. 프로세스가 자체적으로 CPU해체
2. 스케줄러는 준비 대기열의 다음 프로세스로 진행

<br>

- <ins>프로세스가 time quantum보다 길 때</ins>
1. 타이머를 끄고 OS에 인터럽트가 발생
2. 문맥교환 실행
3. 진행했던 프로세스는 준비 대기열의 끝에 삽입

<br>

RR은 다른 알고리즘(ex: SJF)과 결합하면 유용하게 사용된다 (라운드 로빈은 거의 적용되는 편이다)

![라운드 로빈](./img/라운드%20로빈.png)

+) <ins>타임 슬라이스 크기가 중요 (성능과 평균 반환시간에 큰 영향을 미친다)</ins>

너무 길 경우: (선입 선처리 스케줄링과 다를 바 없이) 호위 효과가 생길 여지가 있다.

너무 짧을 경우: 문맥 교환에 발생하는 비용이 커지거나 CPU가 프로세스를 시작 시키기도 전에 문맥교환이 일어나기 때문에 진전이 없어질 수 있다

<br>
<br>

### **최소 잔여 시간 우선 (= SRT, 선점형 SJF, SRTF알고리즘)**

Shortest-Remaining-Time-First: Preemptive SJF scheduling

→ 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업시간이 가장 적은 프로세스가 선택 (남아있는 시간이 더 짧은 걸 선점)

(선점형 최단 작업 우선 스케줄링 = 최소 잔여 시간 우선 스케줄링)

<br>

새로 들어온 프로세스의 CPU brust가 현재 running되고있는 remainning time보다 더 작으면
새로 들어온 프로세스를 먼저 선점시킴

<br>

total waiting time 계산: (각각의 프로세스마다) '시작한 시간 - 도착한 시간' 의 총합

<br>
<br>

### **우선순위 (Priority-base Scheduling)**

→ 프로세스들에게 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘 (우선순위가 같다면 선입 선처리)

<br>

최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 → 우선순위 스케줄링의 일종으로 볼 수 있다.

우선순위 방식으로 하게된다면 기아 현상이 생길 수 있다.

⇒ 에이징으로 해결

<br>

+) <ins>기아 현상</ins>: 우선순위가 높은 프로세스를 우선으로 처리하기 때문에 우선순위가 낮은 프로세스는 큐에 먼저 삽입되었어도 계속 실행이 연기 되는 현상

<ins>에이징</ins>: 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

<br>
<br>

### **다단계 큐**

→ 우선순위별로 준비 큐를 여러 개 사용하는 방식

우선순위 스케줄링의 발전된 형태.

![다단계 큐](./img/다단계%20큐.png)

우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리, 우선순위가 가장 높은 큐가 비어있으면 그다음 우선순위 큐에 있는 프로세스들을 처리

<br>

- <ins>장점</ins>

큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리

큐 마다 각기 다른 스케줄링 알고리즘을 사용할 수 있다. (FCFS, RR 등)

<br>

- <ins>단점</ins>

큐 사이를 이동할 수는 없다

우선순위가 낮은 프로세스는 계속 연기될 여지가 있다. (기아 현상이 발생할 수 있다)

<br>
<br>

### **다단계 피드백 큐 스케줄링 알고리즘 (Multi-Level Feedback Queue(MLFQ) Scheduling)**

→ 어떤  프로세스의 CPU이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘

(구현이 복잡하지만 가장 일반적인 CPU스케줄링 알고리즘)

![다단계 피드백 큐 스케줄링](./img/다단계%20피드백%20큐%20스케줄링.png)

다단계 큐 스케줄링과 비슷하게 작동하지만 프로세스들이 큐 사이를 이동할 수 있다

다단계 큐 스케줄링의 발전된 형태 (다단계 큐 스케줄링 + 동적인 프로세스 우선순위 변화)

<br>

타임 슬라이스만큼 작동을 하고 만약 실행을 다 끝내지 못했다면 다음 우선순위 큐로 들어가면서, <ins>CPU를 오래 사용해야하는 프로세스 (CPU 집중 프로세스)는 점차 우선순위가 낮아진다</ins>

<ins>낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스</ins>가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.

가장 하위 큐는 FCFS로 스케줄링을 실행하게 된다.
